#### 可见性、原子性和有序性问题:并发编程的Bug的源头
通常在并发程序中会出现很多Bug，这些Bug很难追踪和定位，一般我都是为了解决并发问题，而忽略了如线程安全等问题，造成系统出现Bug，我们要定位并发中的Bug，那么就要对并发编程深入的了解，而不是停留在只会用。


#### 源头之一：缓存导致的可见性问题
在单核时代，所有的线程都在一个CPU上运行，CPU 缓存与内存的数据一致性容易解
决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来
说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓
存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的
最新值（线程 A 写过的值）。

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。
多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易
解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如
下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明
显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬
件程序员给软件程序员挖的“坑”。