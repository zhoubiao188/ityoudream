(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{545:function(e,s,n){"use strict";n.r(s);var a=n(21),t=Object(a.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"_1-为什么要使用分布式锁-它解决了什么问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要使用分布式锁-它解决了什么问题"}},[e._v("#")]),e._v(" 1.为什么要使用分布式锁，它解决了什么问题？")]),e._v(" "),n("p",[e._v("锁，顾名思义，就是一份数据在同一时间内只能被一个人使用，不能2个人同时使用。\n对于锁，一般有2种使用场景：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("单机系统：单机系统在多用户多线程并发操作同一份资源（数据）的时候，采用线程加锁的机制，\n即当某个线程获取到该资源（数据）后，立即加锁，当使用完后，再解锁，其它线程就可以接着使用了。\n例如，在JAVA的锁机制synchronize/Lock等。")])]),e._v(" "),n("li",[n("p",[e._v("分布式系统：在分布式系统环境中，单机的线程锁机制是不起作用的，因为系统采用了集群部署在不同的机器上;\n如果是多用户同时访问同一份资源（数据）时，JAVA处理锁机制的synchronize/Lock是起不到作用的，\n因为资源（数据）在不同的服务器之间共享。")])])]),e._v(" "),n("p",[e._v("因此，针对分布式环境，我们必须采用分布式锁。\n分布式锁解决2个问题：")]),e._v(" "),n("ol",[n("li",[e._v("解决多用户操作的幂等性问题\n典型案例：用户下订单操作，为了避免用户重复提交导致出现多条相同订单，一般采用分布式锁来解决订单的幂等性问题。")]),e._v(" "),n("li",[e._v("把多用户的并行操作转化为串行操作\n典型案例：在秒杀系统的高并发减库存操作，例如 库存只剩下3台手机，A用户秒杀2台，B用户也秒杀2台，如果A、B用户同时下单就会出现库存等于-1的情况。")])]),e._v(" "),n("h3",{attrs:{id:"_2-分布式锁必须具备5个特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-分布式锁必须具备5个特性"}},[e._v("#")]),e._v(" 2.分布式锁必须具备5个特性")]),e._v(" "),n("p",[e._v("设计一个好的分布式锁，一般要具备以下4个特性：")]),e._v(" "),n("ol",[n("li",[e._v("互斥性：指不可能同时2个人(线程)以上的人拿到锁。")]),e._v(" "),n("li",[e._v("可用性：redis集群环境下，不能因为某个节点瘫痪，导致客户端不能获取和释放锁。")]),e._v(" "),n("li",[e._v("终止性：为了避免死锁，必须有自动的终止或撤销锁操作，一般是采用超时处理机制。")]),e._v(" "),n("li",[e._v("抢占性：别人（其他线程）已经占了锁，不能私下解锁别人（其他线程）的锁，必须等等锁的释放")]),e._v(" "),n("li",[e._v("可重入性: 同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。")])]),e._v(" "),n("h3",{attrs:{id:"_3-业界有哪些主流的分布式锁实现方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-业界有哪些主流的分布式锁实现方案"}},[e._v("#")]),e._v(" 3.业界有哪些主流的分布式锁实现方案？")]),e._v(" "),n("p",[e._v("目前主流的有三种，如下：")]),e._v(" "),n("ul",[n("li",[e._v("基于数据库实现\n基于数据库来做分布式锁的话，通常是采用数据库的乐观锁或悲观锁来实现。")]),e._v(" "),n("li",[e._v("基于ZooKeeper实现\n基于ZooKeeper，是采用它的临时有序节点来实现的分布式锁。")]),e._v(" "),n("li",[e._v("基于Redis实现\n基于Redis实现的锁机制，主要是依赖redis自身的原子来实现\n以上三种方式都可以实现分布式锁，如果并发量不大的话，直接采用数据库就可以，如果高并发的话，就要考虑zookeeper或redis,但从高并发高性能角度考虑，基于 Redis 实现性能会更好；所以如何选择，还是取决于业务需求。")])]),e._v(" "),n("h3",{attrs:{id:"_4-基于redis的setnx实现分布式锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-基于redis的setnx实现分布式锁"}},[e._v("#")]),e._v(" 4.基于Redis的SETNX实现分布式锁")]),e._v(" "),n("ul",[n("li",[e._v("步骤1：采用SETNX加锁\n采用SETNX 来实现，NX 是not exist 的意思。\n例如：")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("127.0.0.1:6379> setnx lock01 true\n(integer) 1\n127.0.0.1:6379> setnx lock01 true\n(integer) 0\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("p",[e._v("如果 SETNX 返回1，说明拿到锁了。\n如果 SETNX 返回0，说明拿锁失败，被其他线程占用。")]),e._v(" "),n("ul",[n("li",[e._v("步骤2：为了避免死锁，增加超时机制\n为该锁增加10分钟超时，防止死锁")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("127.0.0.1:6379> expire lock01 600\n(integer) 1\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("p",[e._v("以上操作有一个问题?\n无法保证锁的原子性操作，因为要操作2个步骤 setnx   expire\n用以下来代替：")]),e._v(" "),n("p",[e._v("SET key value [NX] [XX] [EX "),n("seconds",[e._v("] [PX [millseconds]] 设置一对key value\n必选参数说明"),n("br"),e._v("\nSET：命令\nkey：待设置的key\nvalue: 设置的key的value")])],1),e._v(" "),n("p",[e._v("可选参数说明"),n("br"),e._v("\nNX：表示key不存在才设置，如果存在则返回NULL\nXX：表示key存在时才设置，如果不存在则返回NULL\nEX seconds：设置过期时间，过期时间精确为秒\nPX millsecond：设置过期时间，过期时间精确为毫秒")]),e._v(" "),n("p",[e._v("以上set 代替了 setnx +expire 需要分2次执行命令操作的方式，保证了原子性")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("127.0.0.1:6379> set lock true NX px 600000\nOK\n127.0.0.1:6379> set lock true NX px 600000\n(nil)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("p",[e._v("如果setnx 返回ok 说明拿到了锁\n如果setnx 返回 nil，说明拿锁失败，被其他线程占用。")]),e._v(" "),n("h3",{attrs:{id:"_5-案例实战-基于redis的分布式锁实现下订单防止重复提交"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-案例实战-基于redis的分布式锁实现下订单防止重复提交"}},[e._v("#")]),e._v(" 5.案例实战：基于redis的分布式锁实现下订单防止重复提交")]),e._v(" "),n("p",[e._v("先来说下这种业务场景：\n用户提交订单的时候，如果客户端APP或JS没做校验的话，用户对订单的提交按钮重复点击，就会造成数据库出现多笔订单。\n为了避免用户重复提交导致数据库出现多条相同订单，一般采用分布式锁来解决订单的幂等性问题。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);