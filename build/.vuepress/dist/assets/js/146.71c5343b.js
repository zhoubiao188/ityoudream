(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{590:function(t,a,r){"use strict";r.r(a);var s=r(21),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"rabbitmq-为什么需要信道-为什么不是tcp直接通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-为什么需要信道-为什么不是tcp直接通信"}},[t._v("#")]),t._v(" RabbitMQ 为什么需要信道？为什么不是Tcp直接通信?")]),t._v(" "),r("p",[t._v("下面是RabbitMQ的原理图\n"),r("img",{attrs:{src:"/rmq/rabbit-yuanli.png",alt:"image"}})]),t._v(" "),r("h3",{attrs:{id:"首先来解释下这些名词"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#首先来解释下这些名词"}},[t._v("#")]),t._v(" 首先来解释下这些名词")]),t._v(" "),r("h3",{attrs:{id:"_1-message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-message"}},[t._v("#")]),t._v(" 1.Message")]),t._v(" "),r("p",[t._v("消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括routing-key(路由键)、priority(相对于其它消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等。")]),t._v(" "),r("p",[t._v("上述就是很多人对Message的理解，但是从我认为，消息就是1个或者多个字符串组成，最终会被解析成RabbitMQ能够识别的。")]),t._v(" "),r("h3",{attrs:{id:"_2-publisher"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-publisher"}},[t._v("#")]),t._v(" 2.Publisher")]),t._v(" "),r("p",[t._v("消息的源头，消息的生产者，同时能向交换器发布消息的客户端程序。")]),t._v(" "),r("h3",{attrs:{id:"_3-consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-consumer"}},[t._v("#")]),t._v(" 3.Consumer")]),t._v(" "),r("p",[t._v("接受者，也可以理解为消息的消费者，标示从消息队列中接受生产者发的消息")]),t._v(" "),r("h3",{attrs:{id:"_4-exchange"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-exchange"}},[t._v("#")]),t._v(" 4.Exchange")]),t._v(" "),r("p",[t._v("交换器，可以理解为机房里面的交换机，是用来接收生产者发来消息并将这些消息通过路由给服务器中的队列。")]),t._v(" "),r("p",[t._v("3种常用的交换器类型：")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("direct（发布与订阅、完全匹配）\nfanout（广播）\ntopic（主题、规则匹配）\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br")])]),r("h3",{attrs:{id:"_5-binding"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-binding"}},[t._v("#")]),t._v(" 5.Binding")]),t._v(" "),r("p",[t._v("绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。")]),t._v(" "),r("h3",{attrs:{id:"_6-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-queue"}},[t._v("#")]),t._v(" 6.Queue")]),t._v(" "),r("p",[t._v("消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。")]),t._v(" "),r("h3",{attrs:{id:"_7-routing-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-routing-key"}},[t._v("#")]),t._v(" 7.routing key")]),t._v(" "),r("p",[t._v("路由键：RabbitMQ决定消息该投递到哪个队列的规则。")]),t._v(" "),r("p",[t._v("队列通过路由键绑定到交换器。")]),t._v(" "),r("p",[t._v("消息发送到MQ服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ也会将其和绑定使用的路由键进行匹配。")]),t._v(" "),r("p",[t._v("如果相匹配，消息将会投递到该队列，\n如果不匹配，消息将会进入黑洞。")]),t._v(" "),r("h3",{attrs:{id:"_8-connection"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-connection"}},[t._v("#")]),t._v(" 8.Connection")]),t._v(" "),r("p",[t._v("指rabbit服务器和服务建立的TCP连接。")]),t._v(" "),r("h3",{attrs:{id:"_9-channel"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-channel"}},[t._v("#")]),t._v(" 9.Channel")]),t._v(" "),r("p",[t._v("1.channel中文叫信道，是TCP里面的虚拟连接。例如：电缆相当于TCP，信道是一条独立光纤束，一条TCP连接上创建多少条信道是没有限制的。")]),t._v(" "),r("p",[t._v("2.TCP一旦打开，就会创建AMQP信道。")]),t._v(" "),r("p",[t._v("3.无论是发布消息、接受消息、订阅队列，这些动作都是通过信道完成的。")]),t._v(" "),r("h3",{attrs:{id:"_10-virtual-host"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-virtual-host"}},[t._v("#")]),t._v(" 10.Virtual Host")]),t._v(" "),r("p",[t._v("虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /")]),t._v(" "),r("h3",{attrs:{id:"_11-broker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-broker"}},[t._v("#")]),t._v(" 11.Broker")]),t._v(" "),r("p",[t._v("表示消息队列服务器实体。")]),t._v(" "),r("h3",{attrs:{id:"交换器和队列的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#交换器和队列的关系"}},[t._v("#")]),t._v(" 交换器和队列的关系")]),t._v(" "),r("p",[t._v("交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列当中去。")]),t._v(" "),r("p",[t._v("也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器再通过路由键匹配分发消息到具体的队列中区。 路由键可以理解为匹配的规则。")]),t._v(" "),r("h3",{attrs:{id:"rabbit-mq为什么需要信道-为什么不是tcp直接通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbit-mq为什么需要信道-为什么不是tcp直接通信"}},[t._v("#")]),t._v(" rabbit mq为什么需要信道？为什么不是TCP直接通信？")]),t._v(" "),r("p",[t._v("1.CTP的创建和销毁，开销大，创建要3次握手，销毁要4次分手。")]),t._v(" "),r("p",[t._v("2.如果不用信道，那应用程序就会tcp连接到rabbit，高峰时每秒成千上万条连接会造成资源的巨大浪费，而且操作系统每秒处理tcp连接数也是有限制的，必定造成性能瓶颈。")]),t._v(" "),r("p",[t._v("3.信道的原理是一条线程一条信道，多条线程多条信道同用一条TCP连接。一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能瓶颈")])])}),[],!1,null,null,null);a.default=e.exports}}]);