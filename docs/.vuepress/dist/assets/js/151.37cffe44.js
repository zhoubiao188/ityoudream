(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{593:function(a,t,r){"use strict";r.r(t);var s=r(21),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"为什么使用rabbitmq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用rabbitmq"}},[a._v("#")]),a._v(" 为什么使用RabbitMQ")]),a._v(" "),r("p",[a._v("因为它解决了三个问题")]),a._v(" "),r("h3",{attrs:{id:"第一个问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一个问题"}},[a._v("#")]),a._v(" 第一个问题")]),a._v(" "),r("h4",{attrs:{id:"同步变异步-那么什么是同步变异步呢-如下图就是个同步业务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步变异步-那么什么是同步变异步呢-如下图就是个同步业务"}},[a._v("#")]),a._v(" 同步变异步,那么什么是同步变异步呢？如下图就是个同步业务")]),a._v(" "),r("p",[r("img",{attrs:{src:"/rmq/async.png",alt:"image"}})]),a._v(" "),r("p",[a._v("如上图，用户下订单，耗费50毫秒，然后订单服务分别去发送短信、email、app-push，各50毫秒，而加起来200毫秒，并且是强耦合，因为订单服务是依赖于短信服务、email服务、app-push服务，一般在互联网上同步用的是比较少的，为什么不用同步呢，因为并发量太大了，无法使用同步来解决问题。")]),a._v(" "),r("h4",{attrs:{id:"那么如何将同步变异步呢-那么传统的做法就是加一个异步线程池-如下图所示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#那么如何将同步变异步呢-那么传统的做法就是加一个异步线程池-如下图所示"}},[a._v("#")]),a._v(" 那么如何将同步变异步呢？那么传统的做法就是加一个异步线程池,如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:"/rmq/chuanton-async.png",alt:"image"}})]),a._v(" "),r("p",[a._v("如上图所示，这个有什么区别呢，只不过多了一个线程池，在下订单完成后，就异步去发消息(短信服务、email服务、app-push服务)，但是这里是有一个优化过的地方，那就是下完订单后，可以不用等待150毫秒，因为这里是异步的。")]),a._v(" "),r("p",[a._v("缺点：需要自己去实现线程池、并且还是强耦合")]),a._v(" "),r("h4",{attrs:{id:"那么异步的rabbitmq是如何处理的呢-如下图所示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#那么异步的rabbitmq是如何处理的呢-如下图所示"}},[a._v("#")]),a._v(" 那么异步的RabbitMQ是如何处理的呢?如下图所示")]),a._v(" "),r("p",[r("img",{attrs:{src:"/rmq/async-rmq.png",alt:"image"}})]),a._v(" "),r("p",[a._v("那么和传统用异步线程池有什么区别呢？首先这里使用的是RabbitMQ的异步队列，并且低耦合，为什么低耦合呢？因为这里订单服务没有依赖(短信服务、email服务、app-push服务)，而是只依赖RabbitMQ系统。")]),a._v(" "),r("p",[a._v("一般在互联网中，同步变异步都是采用RabbitMQ消息队列来实现的，很少采用线程池来实现。")]),a._v(" "),r("h3",{attrs:{id:"第二个问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二个问题"}},[a._v("#")]),a._v(" 第二个问题")]),a._v(" "),r("p",[a._v("高内聚低耦合：结耦")]),a._v(" "),r("p",[a._v("为什么使用了RabbitMQ就能解决高内聚低耦合呢？如下图所示\n"),r("img",{attrs:{src:"/rmq/rmq-ouhe.png",alt:"image"}})]),a._v(" "),r("p",[a._v("如上图所示，如果项目经理说需要给微信发送消息，那么这下就完了，因为如果你没有采用RabbitMQ，那么就要去改订单服务的代码，很麻烦。但是你使用了RabbitMQ的话，那么订单服务的代码是一行都不需要改的，因为订单服务是依赖于MQ系统。但是呢你的微信服务就要加一行代码，什么代码呢？微信订阅RabbitMQ的代码就可以了。所以这里的订单服务是不知道后面的(短信服务、email服务、app-push服务、微信服务)的，订单服务只依赖于MQ系统，而MQ系统才知道我要给谁发。这样就完成了结耦。")]),a._v(" "),r("p",[a._v("结偶：一般是用在关闭原则中： 对修改关闭，对新增业务扩展开放，开闭原则")]),a._v(" "),r("h3",{attrs:{id:"第三个问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第三个问题"}},[a._v("#")]),a._v(" 第三个问题")]),a._v(" "),r("p",[a._v("流量削峰")]),a._v(" "),r("h4",{attrs:{id:"什么是流量削峰"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是流量削峰"}},[a._v("#")]),a._v(" 什么是流量削峰")]),a._v(" "),r("p",[a._v("流量削峰一般指的是电商购物网站中的，秒杀活动，在秒杀活动中，流量非常大，几秒就是几千万请求，服务器很容易就被请求给阻塞宕机。")]),a._v(" "),r("p",[a._v("那么如何解决这样的问题呢，那么就是在秒杀系统中加一个消息队列，它呢可以控制人数，当超过一定的人数，那么就让超过人数的其它订单作废(丢弃)、同时能缓解某一时刻的高并发请求")]),a._v(" "),r("p",[a._v("RabbitMQ的流量削峰处理如下图所示\n"),r("img",{attrs:{src:"/rmq/rmq-dangji.png",alt:"image"}})]),a._v(" "),r("p",[a._v("当大量用户请求进入的时候，系统装载到消息队列，加入到消息队列后，在消息队列中设置它的最大值，如果请求数量超过了设置的最大值，那么将超过的用户信息直接抛弃掉或者转到一个错误页面，而秒杀业务呢根据消息队列的请求再做一个后续的处理，列如做一个下单处理。")])])}),[],!1,null,null,null);t.default=v.exports}}]);