#### MongoDB 设计模式解决问题

#### 问题: 大文档，很多字段，很多索引
```json
{
    title: "Dunkirk",
    ...
    release_USA: "2017/07/23",
    release_UK: "2017/08/01",
    release_France: "2017/08/01",
    release_Festival_San_Jose:
    "2017/07/22"
}
```

例如一个电影叫Dunkirk，美国上映时间2017/07/23，而英国是2017/08/01，法国是2017/08/01，那么有很多个国家我就要建立很多个字段来表示，并且在检索的时候，我们希望的是通过索引，那么就要建立很多个索引，如下
```json
    { release_USA: 1 }
    { release_UK: 1 }
    { release_France: 1 }
    ...
    { release_Festival_San_Jose: 1 }
...
```
这样为每一个字段都建立索引非常都麻烦，如果有100个地区，我就要建立100个，那么这种情况如何解决呢？

#### 解决方案: 列转行
```javascript
{
    title: "Dunkirk",
    ...
    release_USA: "2017/07/23",
    release_UK: "2017/08/01",
    release_France: "2017/08/01",
    release_Festival_San_Jose:
    "2017/07/22"
}
```
我们可以通过将列转化为行来表示如下表示
```javascript
{
  title: "Dunkirk",
  ...
  releases: [
  { country: “USA”, date:”2017/07/23”},
  { country: “UK”, date:”2017/08/01”}
  ]
}
```
代码就是：
```javascript
db.movies.createIndex({“releases.country”:1, “releases.date”:1})
```
可以看见我们通过数组都方式来建立，这里把国家和日期组合，我只需查询一个索引就支持所有国家都查询

#### 模式小结： 列转行
|  场景   | 痛点  | 设计模式方案及优点  |
|  ----  | ---- |  ---- |
|  产品属性 ‘color’, ‘size’,‘dimensions’, ... \\n 多语言（多国家）属性 | 文档中有很多类似的字段 \\n 会用于组合查询搜索，需要见很多索引 | 转化为数组，一个索引解决所有查询问题  |

#### 问题: 模型灵活了，如何管理文档不同版本？
2020.12 版本1.0
```javascript
{
    "_id" : ObjectId("5de26f197edd62c5d388babb"),
    "name" : "custer1",
    "company" : "ityoudream.cn",
}
```

2021.1 版本2.0 新增“wechat”字段
```javascript
{
    "_id" : ObjectId("5de26f197edd62c5d388babb"),
    "name" : "custer1",
    "company" : "ityoudream.cn",
    "wechat": "dreamalip8"
```

可以看到2020.12 版本1.0和2021.1 版本2.0的区别是多了一个wechat字段，那么我们如何来做版本控制呢？

#### 解决方案: 增加一个版本字段
我们可以在2021.1 版本中增加一个“schema_version“字段来控制版本，类似与maven依赖中的version标记一样
|  场景   | 痛点  | 设计模式方案及优点  |
|  ----  | ---- |  ---- |
| 任何有版本衍变的数据库 | 文档模型格式多，无法知道其合理性 \\n 升级时候需要更新太多文档 | 增加一个版本号字段 \\n 快速过滤掉不需要升级的文档 \\n 升级时候对不同版本的文档做不同的处理 |

#### 问题: 统计网页点击流量
![image](/mongodb/counter.png) 

```
每访问一个页面都会产生一次数据库计数更新操作

统计数字准确性并不十分重要
```

比如说我们需要做一个网站流量的统计排行榜，我要统计这个页面或者某一个商品被看了多少次，那么最简单的做法就是AuditLog(日志统计)或者WriteDB(写入统计)，假如使用了counter做计数器那么，用户每点击一次就会操作变量+1，同时数据库update，这样频繁的update在高并发情况下一定会蹦的，那么在mongo里面如何解决呢？


#### 解决方案: 用近似计算(间隔写入)
mongodb 有一个 increment by 操作也就是inc函数，每增加一次，我就更新一下计数器counter，如果不保证准确性的话，我们可以通过这种近似计算，每10次增加1次，这样总的来说，我们写入的量会减少10倍，那么它的底层是通过random来实现的，10次也就是random(0,9)就是0到9的范围

![image](/mongodb/sj1.png) 

#### 模式小结：近似计算
|  场景   | 痛点  | 设计模式方案及优点  |
|  ----  | ---- |  ---- |
| 网页计数 \\n 各种结果不需要准确的排名 | 写入太频繁，消耗系统资源 | 间隔写入，每隔10次或者100次 \\n 大量减少写入需求 |

#### 问题: 业绩排名，游戏排名，商品统计等精确统计
```
热销榜：某个商品今天卖了多少，这个星期卖了多少，这个月卖了多少？

电影排行：观影者，场次统计

传统解决方案：通过聚合计算

痛点：消耗资源多，聚合计算时间长
```
如果使用传统的解决方案来解决上面的问题，会建立很多个文档，那么会花很多时间去处理，那么系统资源就会被卡住，那么我们如何解决呢？

#### 解决方案: 用预聚合字段
```javascript
{
    product: ”m1 mac book pro",
    sku: “abc123456”,
    quantitiy: 20394,
    daily_sales: 40,
    weekly_sales: 302,
    monthly_sales: 1419
}
```
这是一个商品，可以看到我们通过增加预聚合字段daily_sales字段以天来统计，weekly_sales以周来统计，monthly_sales以月来统计，在mongo里面多了这几个字段是完全不影响使用和性能的，当我们每次修改库存的时候也就是quantitiy，那么同时会修改daily_sales、weekly_sales、monthly_sales，这样就解决了问题，并且性能会提升百倍千倍。

#### 模式小结：预聚合
|  场景   | 痛点  | 设计模式方案及优点  |
|  ----  | ---- |  ---- |
| 准确排名排行榜 | 统计计算耗时，计算时间长  | 模型中直接增加统计字段 \\n 每次更新数据时候同时更新统计值 |

#### MongoDB 文档模型设计：小结
![image](/mongodb/sj2.png) 


