#### 互斥锁（上）：解决原子性问题
一个或者多个操作在 CPU 执行的过程中不被中断的特性，称
为“原子性”。理解这个特性有助于你分析并发编程 Bug 出现的原因，例如利用它可以分
析出 long 型变量在 32 位机器上读写可能出现的诡异 Bug，明明已经把变量成功写入内
存，重新读出来却不是自己写入的。

##### 那原子性问题到底该如何解决呢？
原子性的问题的源头是来自`线程切换`，我想如果能够禁用线程切换就能解决这个问题，但是操作系统做线程切换是依赖CPU中断的，所以禁止CPU发生中断就能禁止线程切换。

我们要知道，在单核CPU时代，这种利用禁止线程切换的方案是可行的，但是并不能解决多核场景，下面我们以32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低
32 位，如下图所示）。

![image](/thread/thread-yzx-1.png)

在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会
重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所
以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。
但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1
上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执
行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位
的话，那就有可能出现我们开头提及的诡异 Bug 了。

`同一时刻只有一个线程执行`这个条件非常重要，我们称之为`互斥`。如果我们能够保证
对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性
了。

#### 简易锁模型
我们可以通过加锁来解决这种互斥问题，如下面图所示


![image](/thread/thread-yzx-2.png)

<center>简易锁模型</center>

我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁
lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持
有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。
这个过程非常像办公室里高峰期抢占坑位，每个人都是进坑锁门（加锁），出坑开门（解
锁），如厕这个事就是临界区。很长时间里，我也是这么理解的。这样理解本身没有问
题，但却很容易让我们忽视两个非常非常重要的点：我们锁的是什么？我们保护的又是什
么？

